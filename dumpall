#!/usr/bin/env bash
#
#       _                             _ _     
#    __| |_   _ _ __ ___  _ __   __ _| | |    
#   / _` | | | | '_ ` _ \| '_ \ / _` | | |    
#  | (_| | |_| | | | | | | |_) | (_| | | |  _ 
#   \__,_|\__,_|_| |_| |_| .__/ \__,_|_|_| (_)
#                        |_|                  
#                            Version: #VERSION
# 
# dumpall - Display contents of files with separators
# 
# USAGE:
#   dumpall [options] <file_or_directory>
#
# DESCRIPTION:
#   Displays the contents of all files in a directory, or a single file,
#   in a Markdown format ideal for AI model context or code sharing.
#
# OPTIONS:
#   -e, --exclude <name>  Exclude files or directories by name. Can be used multiple times.
#   -c, --clip            Copy the output directly to the clipboard.
#   --color               Enable colorized output for display in a terminal.
#   --no-progress         Disable the progress indicator animation.
#   -v, --version         Show the current version of the script.
#   -h, --help            Show this help message.
#
# ENVIRONMENT VARIABLES:
#   DUMPALL_CLIP_CMD      Overrides the default clipboard command (e.g., 'my-clip-tool').
#

# --- Configuration ---
VERSION="1.0.0"
SPINNER="/-\|" # Characters for the spinner animation

# Color definitions for --color flag
C_YELLOW='\033[1;33m'
C_RESET='\033[0m'

# --- Helper Functions ---
print_error() {
    # Prints a message to stderr
    echo "Error: $1" >&2
}

get_language() {
    local filename="$1"
    local extension="${filename##*.}"
    case "$extension" in
        js) echo "javascript" ;;
        ts) echo "typescript" ;;
        py) echo "python" ;;
        rb) echo "ruby" ;;
        sh) echo "bash" ;;
        sql) echo "sql" ;;
        md) echo "markdown" ;;
        json) echo "json" ;;
        html) echo "html" ;;
        css) echo "css" ;;
        yml|yaml) echo "yaml" ;;
        *) echo "" ;; # Default to no language identifier
    esac
}

# Determines the correct clipboard command for the OS
get_clipboard_command() {
    # 1. Prioritize user-defined environment variable
    if [ -n "$DUMPALL_CLIP_CMD" ]; then
        echo "$DUMPALL_CLIP_CMD"
        return
    fi

    # 2. Auto-detect based on OS
    case "$(uname)" in
        "Linux")
            if command -v wl-copy &> /dev/null; then
                echo "wl-copy"
            elif command -v xclip &> /dev/null; then
                echo "xclip -selection clipboard"
            fi
            ;;
        "Darwin")
            echo "pbcopy"
            ;;
        MINGW*|MSYS*|CYGWIN*)
            echo "clip.exe"
            ;;
    esac
}

# --- Argument Parsing ---
TARGET=""
EXCLUDE_PATTERNS=()
USE_CLIP=false
SHOW_PROGRESS=true
USE_COLOR=false

# Show help if no arguments are given
if [ $# -eq 0 ]; then
    sed -n '2,/^$/p' "$0" | sed "s/#VERSION/$VERSION/" | sed 's/^# //' | sed 's/^#//'
    exit 0
fi

while [ $# -gt 0 ]; do
    case "$1" in
        -e|--exclude)
            [ -n "$2" ] && EXCLUDE_PATTERNS+=("$2") && shift 2 || { print_error "--exclude requires a value."; exit 1; }
            ;;
        -c|--clip)
            USE_CLIP=true
            shift
            ;;
        --color)
            USE_COLOR=true
            shift
            ;;
        --no-progress)
            SHOW_PROGRESS=false
            shift
            ;;
        -h|--help)
            sed -n '2,/^$/p' "$0" | sed "s/#VERSION/$VERSION/" | sed 's/^# //' | sed 's/^#//'
            exit 0
            ;;
        -v|--version)
            echo "dumpall version $VERSION"
            exit 0
            ;;
        -*)
            print_error "Unknown option '$1'"
            exit 1
            ;;
        *)
            [ -n "$TARGET" ] && { print_error "Multiple targets specified."; exit 1; }
            TARGET="$1"
            shift
            ;;
    esac
done

# --- Sanity Checks ---
if [ "$USE_COLOR" = true ] && [ "$USE_CLIP" = true ]; then
    print_error "The --color and --clip options cannot be used together."
    print_error "Please choose one: --color for display or --clip for raw text."
    exit 1
fi

if [ -z "$TARGET" ]; then
    print_error "No file or directory specified."
    exit 1
fi

# --- Pre-flight Checks for Clipboard ---
CLIP_CMD=""
if [ "$USE_CLIP" = true ]; then
    CLIP_CMD=$(get_clipboard_command)
    if [ -z "$CLIP_CMD" ]; then
        print_error "Could not find a clipboard command for your OS."
        print_error "Please install one (e.g., xclip, wl-copy) or set DUMPALL_CLIP_CMD."
        exit 1
    fi
    # Check if the command actually exists
    if ! command -v "${CLIP_CMD%% *}" &> /dev/null; then
        print_error "Clipboard command '${CLIP_CMD%% *}' not found."
        print_error "Please install it or set DUMPALL_CLIP_CMD to a command in your PATH."
        exit 1
    fi
fi

# --- Main Logic ---

# This function contains the core loop for processing files.
process_files() {
    # Temporarily disable debug output (set -x) during the spinner to prevent visual glitches
    if [[ $- == *x* ]]; then
        set +x
        local reenable_debug=true
    fi

    local counter=0
    # Use find -print0 and read -d '' to handle all filenames safely
    while IFS= read -r -d '' file; do
        # Only process text files
        if file "$file" | grep -q "text"; then
            
            # 1. Clear the previous spinner line BEFORE printing file content
            if [ "$SHOW_PROGRESS" = true ]; then
                echo -n -e "\r\033[K" >&2
            fi

            # 2. Print the file content in Markdown format
            local lang
            lang=$(get_language "$file")
            if [ "$USE_COLOR" = true ]; then
                echo -e "${C_YELLOW}\`\`\`${lang} ${file}${C_RESET}"
                cat "$file"
                echo
                echo -e "${C_YELLOW}\`\`\`${C_RESET}"
            else
                echo "\`\`\`${lang} ${file}"
                cat "$file"
                echo
                echo "\`\`\`"
            fi
            echo
        fi

        ((counter++))
        # 3. Update spinner on stderr AFTER processing the file
        if [ "$SHOW_PROGRESS" = true ]; then
            local index=$(( counter % ${#SPINNER} ))
            echo -n -e "\r[${SPINNER:$index:1}] Processing file #$counter..." >&2
        fi
    done
    
    # After the loop, clear the final spinner line from the screen
    if [ "$SHOW_PROGRESS" = true ] && [ "$counter" -gt 0 ]; then
        echo -n -e "\r\033[K" >&2
    fi

    # Re-enable debug output if it was on before this function
    if [ "$reenable_debug" = true ]; then
        set -x
    fi
}

# Build the find command's exclude arguments
FIND_EXCLUDES=()
for pattern in "${EXCLUDE_PATTERNS[@]}"; do
    FIND_EXCLUDES+=(-name "$pattern" -prune -o)
done

# Main execution path
if [ -f "$TARGET" ]; then
    # Handling a single file
    lang=$(get_language "$TARGET")
    header="\`\`\`${lang} ${TARGET}"
    footer="\`\`\`"
    
    if [ "$USE_COLOR" = true ]; then
        header="${C_YELLOW}${header}${C_RESET}"
        footer="${C_YELLOW}${footer}${C_RESET}"
    fi

    # Construct final output in a way that handles multi-line content safely
    {
        echo -e "$header"
        cat "$TARGET"
        echo
        echo -e "$footer"
    } | {
        OUTPUT=$(cat)
        if [ "$USE_CLIP" = true ]; then
            echo -n "$OUTPUT" | $CLIP_CMD
            echo "Copied to clipboard! ðŸ“‹âœ¨"
        else
            echo "$OUTPUT"
        fi
    }
elif [ -d "$TARGET" ]; then
    # Handling a directory
    FIND_CMD="find \"$TARGET\" ${FIND_EXCLUDES[@]} -type f -print0"

    if [ "$USE_CLIP" = true ]; then
        # Capture all file content into a variable first.
        ALL_CONTENT=$(eval "$FIND_CMD" | process_files)
        
        # After everything is collected, send the complete data to the clipboard.
        echo -n "$ALL_CONTENT" | $CLIP_CMD
        echo "Copied to clipboard! ðŸ“‹âœ¨"
    else
        # If not clipping, stream the output directly to the screen as before.
        eval "$FIND_CMD" | process_files
    fi
else
    print_error "'$TARGET' is not a file or directory"
    exit 1
fi